# GraphQL API

GraphQL API is available at `/api/graphql` of the server.

API documentation is generated automatically and available at [/docs/graphql](/docs/graphql ':ignore').

## Errors & Exceptions

GraphQL endpoint **responds with "200 OK"** if server successfully processed the request
(i.e. if no unexpected exception occurred).

There are two types of errors that could happen: user input related (validations) and exceptions.

**Validations errors** may present **only in mutations** and are included into the data (i.e. `response.data.errors`) (using [ValidationErrors type](/docs/graphql/validationerrors.doc.html ':ignore')). They're meant to provide a useful feedback to user and could be displayed in the UI.

**Exceptions** could happen in any query and signalize that something went wrong with the query: for example, authentication/authorization issues, unprocessable input data, etc. (see below).
The client must "fail" when response contains an exception (e.g. show an error screen).

Client must check for `errors` field in the response to check for exceptions.

We add additional metadata to known exceptions via _errors extensions_:

```json
{
  "errors": [
    {
      "message": "Error message",
      // metadata
      "extensions": {
        // exception code (type) which could be used by client
        // to handle this exception
        "code": "under_scored_type"
        // optional
      }
    }
  ]
}
```

### Exceptions Codes

code                | description                                | reason
--------------------|--------------------------------------------|------------
`unauthenticated`   | User is not authenticated                  | `token_expired` - when token is expired; `token_invalid` - when any other reason, `user_not_found` - when token is not provided or user not found
`non_member`        | User is disabled                           | `disabled` - when user is temporary disabled
`not_found`         | Resource has not been found                | underscored resource name
`unauthorized`      | Authorization check failed (not enough permissions)  | Instead of `"reason"` field it may contain `"fullMessages"` and `"details"` fields generated by the policy (see [Action Policy docs](https://actionpolicy.evilmartians.io/#/reasons))
`unprocessable_entity`  | The data sent by client is invalid or corrupted | `invalid_blob` (e.g. when Blob with the signed ID couldn't be found)

## Direct File Uploads

We provide direct uploads API for uploading files via API.

**NOTE**: "direct uploads" means that files uploaded directly to the storage service (e.g. S3),
without passing through the Rails app.

In order to upload a file a client must do the following steps:
- Obtain file metadata (filename, size, content type and **MD5 checksum encoded as base64**)
- Request direct upload credentials and `signed_blob_id` (or `id`) via API â€“ `createDirectUpload` mutation.
- Upload file using the credentials (no GraphQL involved, HTTP PUT request)
- (optional) Submit `signed_blob_id` as a mutation argument to "attach" the uploaded file to a record.

Resources:
- [Active Storage meets GraphQL: Direct Uploads](https://dev.to/evilmartians/active-storage-meets-graphql-direct-uploads-3n38)
- [Active Storage overview](https://edgeguides.rubyonrails.org/active_storage_overview.html#direct-uploads)
- [Rails JavaScript client for Active Storage with direct uploads support](https://github.com/rails/rails/tree/v6.0.0.beta3/activestorage/app/javascript/activestorage)

## Subscriptions

Subscriptions allow GraphQL clients to observe specific events and receive updates from the server when those events occur. This supports live updates, such as websocket pushes.

Subscriptions introduce several new concepts:

- The Subscription type is the entry point for subscription queries
- Triggers begin the update process
- The Implementation provides application-specific methods for executing & delivering updates.

Besides the GraphQL component, our application must provide some subscription-related plumbing. We use ActionCable protocol to achieve that. But, Ruby isn't well suitable for handling web-socket connection, so, eventually we are using AnyCable implementation.

Cable API is available at `/cable` of the server (i.e. ws://localhost:3334/cable in the development environment).

First, send the subscribe command:

```json
{
  "command": "subscribe",
  "identifier": "{ \"channel\": \"CoreBy::GraphQLChannel\" }"
}
```

Then send the actual GraphQL subscription command:

So the data item actually contains the GraphQL stuff, everything else is related to ActionCable. Ensure the action item is included as that tells ActionCable which function to call in the channel (in our case execute).

```json
{
  "command": "message",
  "identifier": "{\"channel\":\"CoreBy::GraphQLChannel\"}",
  "data": "{ \"query\": \"subscription { taskAdded(taskId: 1) } { ... }\", \"variables\": null, \"action\": \"execute\" }"
}
```

At the end of a session, send the unsubscribe command:

```json
{
  "command": "unsubscribe",
  "identifier": "{ \"channel\": \"CoreBy::GraphQLChannel\" }"
}
```
